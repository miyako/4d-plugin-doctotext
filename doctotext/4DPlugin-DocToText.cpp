/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-DocToText.cpp
 #	source generated by 4D Plugin Wizard
 #	Project :  DocToText
 #	author : miyako
 #	2021/12/02
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-DocToText.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// ---  DocToText
            
			case 1 :
				DocToText(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

using namespace doctotext;

static void convert_path(CUTF16String& u16, std::string& u8) {
#if VERSIONMAC
    NSString *path = [[NSString alloc]initWithCharacters:u16.c_str() length:u16.length()];
    if(path) {
        
        NSURL *url = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)path, kCFURLHFSPathStyle, false);
        
        if(url) {
            u8 = (const char *)[(NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLPOSIXPathStyle) UTF8String];
            [url release];
        }
        [path release];
    }
#endif
}

void DocToText(PA_PluginParameters params) {

    PA_Unistring *u = PA_GetStringParameter(params, 1);
    CUTF16String u16(u->fString, u->fLength);
    
    std::string path;
    
#if VERSIONWIN
    u16_to_u8(u16, path);
#else
    convert_path(u16, path);
#endif
    
    PA_ObjectRef status = PA_CreateObject();
    ob_set_b(status, L"success", false);
    
    PA_Variable Param3 = PA_CreateVariable(eVK_ArrayBlob);
    
    PA_Handle h = PA_GetBlobHandleParameter(params, 1);
    
    if(h) {
        
        PlainTextExtractor::ParserType parser_type = PlainTextExtractor::PARSER_DOC;
        
        bool verbose = false;
        XmlParseMode mode = PARSE_XML;
        FormattingStyle fmt;
        fmt.table_style = TABLE_STYLE_TABLE_LOOK;
        fmt.list_style.setPrefix(" * ");
        fmt.url_style = URL_STYLE_UNDERSCORED;
        
        PA_ObjectRef options = PA_GetObjectParameter(params, 2);
        if(options) {
            
            CUTF8String xml;
            if(ob_get_s(options, L"xml", &xml)) {
                if(xml == (const uint8_t *)"fix"){
                    mode = FIX_XML;
                }
                if(xml == (const uint8_t *)"strip"){
                    mode = STRIP_XML;
                }
            }
            
            CUTF8String table;
            if(ob_get_s(options, L"table", &table)) {
                if(table == (const uint8_t *)"row"){
                    fmt.table_style = TABLE_STYLE_ONE_ROW;
                }
                if(xml == (const uint8_t *)"col"){
                    fmt.table_style = TABLE_STYLE_ONE_COL;
                }
            }
            
            CUTF8String url;
            if(ob_get_s(options, L"url", &url)) {
                if(url == (const uint8_t *)"text"){
                    fmt.url_style = URL_STYLE_TEXT_ONLY;
                }
                if(url == (const uint8_t *)"extended"){
                    fmt.url_style = URL_STYLE_EXTENDED;
                }
            }
            
            CUTF8String list;
            if(ob_get_s(options, L"list", &list)) {
                fmt.list_style.setPrefix((const char *)list.c_str());
            }

            verbose = ob_get_b(options, L"verbose");
            
            CUTF8String format;
            if(ob_get_s(options, L"format", &format)) {
                
                if(format == (const uint8_t *)".rtf"){
                    parser_type = PlainTextExtractor::PARSER_RTF;goto set_parser_type;
                }
                
                if(format == (const uint8_t *)".fodp"){
                    parser_type = PlainTextExtractor::PARSER_ODFXML;goto set_parser_type;
                }
                if(format == (const uint8_t *)".fods"){
                    parser_type = PlainTextExtractor::PARSER_ODFXML;goto set_parser_type;
                }
                if(format == (const uint8_t *)".fodt"){
                    parser_type = PlainTextExtractor::PARSER_ODFXML;goto set_parser_type;
                }
                if(format == (const uint8_t *)".fodg"){
                    parser_type = PlainTextExtractor::PARSER_ODFXML;goto set_parser_type;
                }
                
                if(format == (const uint8_t *)".odt"){
                    parser_type = PlainTextExtractor::PARSER_ODF_OOXML;goto set_parser_type;
                }
                if(format == (const uint8_t *)".ods"){
                    parser_type = PlainTextExtractor::PARSER_ODF_OOXML;goto set_parser_type;
                }
                if(format == (const uint8_t *)".odp"){
                    parser_type = PlainTextExtractor::PARSER_ODF_OOXML;goto set_parser_type;
                }
                if(format == (const uint8_t *)".odg"){
                    parser_type = PlainTextExtractor::PARSER_ODF_OOXML;goto set_parser_type;
                }
                
                if(format == (const uint8_t *)".docx"){
                    parser_type = PlainTextExtractor::PARSER_ODF_OOXML;goto set_parser_type;
                }
                if(format == (const uint8_t *)".pptx"){
                    parser_type = PlainTextExtractor::PARSER_ODF_OOXML;goto set_parser_type;
                }
                if(format == (const uint8_t *)".xlsx"){
                    parser_type = PlainTextExtractor::PARSER_ODF_OOXML;goto set_parser_type;
                }

                if(format == (const uint8_t *)".doc"){
                    parser_type = PlainTextExtractor::PARSER_DOC;goto set_parser_type;
                }
                if(format == (const uint8_t *)".ppt"){
                    parser_type = PlainTextExtractor::PARSER_PPT;goto set_parser_type;
                }
                if(format == (const uint8_t *)".xls"){
                    parser_type = PlainTextExtractor::PARSER_XLS;goto set_parser_type;
                }

                if(format == (const uint8_t *)".xlsb"){
                    parser_type = PlainTextExtractor::PARSER_XLSB;goto set_parser_type;
                }
                
                if(format == (const uint8_t *)".pages"){
                    parser_type = PlainTextExtractor::PARSER_IWORK;goto set_parser_type;
                }
                if(format == (const uint8_t *)".numbers"){
                    parser_type = PlainTextExtractor::PARSER_IWORK;goto set_parser_type;
                }
                if(format == (const uint8_t *)".key"){
                    parser_type = PlainTextExtractor::PARSER_IWORK;goto set_parser_type;
                }

                if(format == (const uint8_t *)".html"){
                    parser_type = PlainTextExtractor::PARSER_HTML;goto set_parser_type;
                }
                if(format == (const uint8_t *)".pdf"){
                    parser_type = PlainTextExtractor::PARSER_PDF;goto set_parser_type;
                }
                if(format == (const uint8_t *)".eml"){
                    parser_type = PlainTextExtractor::PARSER_EML;goto set_parser_type;
                }
            }
        }
     
    set_parser_type:
        (0);
        
        PlainTextExtractor extractor(parser_type);
        if (verbose)
            extractor.setVerboseLogging(true);
        
        if (mode != PARSE_XML)
            extractor.setXmlParseMode(mode);
        
        extractor.setFormattingStyle(fmt);
        
        /*
         
         it seems the buffer constructor just doesn't work
         
         extractor.processFile(PA_LockHandle(h), PA_GetHandleSize(h), text)
         */
        
        std::string text;
        
        if (extractor.processFile(parser_type, false, path.c_str(), text)) {
            
            ob_set_b(status, L"success", true);
            ob_set_s(status, L"text", text.c_str());
            
            std::vector<Link> links;
            extractor.getParsedLinks(links);
            PA_CollectionRef ll = PA_CreateCollection();
            
            if (links.size() > 0)
            {
                for (size_t i = 0; i < links.size(); ++i)
                {
                    PA_ObjectRef l = PA_CreateObject();
                    ob_set_s(l, L"url", links[i].getLinkUrl());
                    ob_set_n(l, L"position", links[i].getLinkTextPosition());
                    ob_set_s(l, L"text", links[i].getLinkText());
                    PA_Variable v = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&v, l);
                    PA_SetCollectionElement(ll, PA_GetCollectionLength(ll), v);
                }
            }
            ob_set_c(status, L"links", ll);
            
            std::vector<Attachment> attachments;
            extractor.getAttachments(attachments);
            PA_CollectionRef aa = PA_CreateCollection();
            
            if (attachments.size() > 0)
            {
                for (size_t i = 0; i < attachments.size(); ++i)
                {
                    PA_ObjectRef a = PA_CreateObject();
                    ob_set_s(a, L"name", attachments[i].filename());
                    ob_set_n(a, L"data", i);
                    
                    PA_Variable element = PA_CreateVariable(eVK_Blob);
                    PA_SetBlobVariable(&element,
                                       (void *)attachments[i].binaryContent(),
                                       attachments[i].binaryContentSize());
                    
                    PA_ResizeArray(&Param3, i);
                    PA_SetBlobInArray(Param3, i, element.uValue.fBlob);

                    PA_ObjectRef f = PA_CreateObject();
                    std::map<std::string, Variant> variables = attachments[i].getFields();
                    for (std::map<std::string, Variant>::iterator it = variables.begin(); it != variables.end(); ++it)
                    {
                        ob_set_s(f, it->first.c_str(), it->second.getString());
                    }
                    ob_set_o(a, L"fields", f);
                    PA_Variable v = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&v, a);
                    PA_SetCollectionElement(aa, PA_GetCollectionLength(aa), v);
                }
            }
            ob_set_c(status, L"attachments", aa);
        }
        
        Metadata meta;
        
        if (extractor.extractMetadata(path.c_str(), meta))
        {
            
            PA_ObjectRef m = PA_CreateObject();
            ob_set_s(m, L"author", meta.author());
            ob_set_s(m, L"lastModifiedBy", meta.lastModifiedBy());
            ob_set_n(m, L"wordCount", meta.wordCount());
            ob_set_n(m, L"pageCount", meta.pageCount());
            
            ob_set_n(m, L"authorType", meta.authorType());
            ob_set_n(m, L"pageCountType", meta.pageCountType());
            ob_set_n(m, L"wordCountType", meta.wordCountType());

            ob_set_s(m, L"creationDate", date_to_string(meta.creationDate()).c_str());
            ob_set_s(m, L"lastModificationDate", date_to_string(meta.lastModificationDate()).c_str());

            ob_set_n(m, L"lastModifiedByType", meta.lastModifiedByType());
            ob_set_n(m, L"lastModificationDateType", meta.lastModificationDateType());

            ob_set_o(status, L"meta", m);
        }
            
        PA_UnlockHandle(h);
    }
    
    PA_SetVariableParameter(params, 3, Param3, 0);
    PA_ReturnObject(params, status);
}

#pragma mark -

static void u16_to_u8(CUTF16String& u16, std::string& u8) {
    
#ifdef _WIN32
    int len = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)u16.c_str(), u16.length(), NULL, 0, NULL, NULL);
    
    if(len){
        std::vector<uint8_t> buf(len + 1);
        if(WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)u16.c_str(), u16.length(), (LPSTR)&buf[0], len, NULL, NULL)){
            u8 = std::string((const char *)&buf[0]);
        }
    }else{
        u8 = std::string((const char *)"");
    }

#else
    CFStringRef str = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar *)u16.c_str(), u16.length());
    if(str){
        size_t size = CFStringGetMaximumSizeForEncoding(CFStringGetLength(str), kCFStringEncodingUTF8) + sizeof(uint8_t);
        std::vector<uint8_t> buf(size);
        CFIndex len = 0;
        CFStringGetBytes(str, CFRangeMake(0, CFStringGetLength(str)), kCFStringEncodingUTF8, 0, true, (UInt8 *)&buf[0], size, &len);
        u8 = std::string((const char *)&buf[0], len);
        CFRelease(str);
    }
#endif
}

static void u8_to_u16(std::string& u8, CUTF16String& u16) {
    
#ifdef _WIN32
    int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)u8.c_str(), u8.length(), NULL, 0);
    
    if(len){
        std::vector<uint8_t> buf((len + 1) * sizeof(PA_Unichar));
        if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)u8.c_str(), u8.length(), (LPWSTR)&buf[0], len)){
            u16 = CUTF16String((const PA_Unichar *)&buf[0]);
        }
    }else{
        u16 = CUTF16String((const PA_Unichar *)L"");
    }
    
#else
    CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)u8.c_str(), u8.length(), kCFStringEncodingUTF8, true);
    if(str){
        CFIndex len = CFStringGetLength(str);
        std::vector<uint8_t> buf((len+1) * sizeof(PA_Unichar));
        CFStringGetCharacters(str, CFRangeMake(0, len), (UniChar *)&buf[0]);
        u16 = CUTF16String((const PA_Unichar *)&buf[0]);
        CFRelease(str);
    }
#endif
}
